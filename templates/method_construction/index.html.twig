{% extends 'base_fluid.html.twig' %}

{% block title %}Situational Method Construction{% endblock %}

{% block body %}

    {# Situational Checkboxes #}
    <div id="situational-factor-box">
        <h3 class="text-center mt-3">Situational Factors</h3>
        <div class="d-flex flex-row justify-content-between p-1 flex-wrap border border-dark rounded m-auto"
             style="width: 90%;">
            {% for factor in situationalFactors %}
                <div class="d-flex flex-column m-2">
                    <h6><u>{{ factor.name }}</u></h6>
                    <div id="factor-{{ factor.id }}" class="d-flex flex-column align-items-start">
                        {% for variant in factor.variants %}
                            <label><input type="checkbox" name="factor-{{ factor.id }}-variant-{{ variant }}"
                                          value="{{ factor~" : "~variant }}">{{ variant }}</label>
                        {% endfor %}
                    </div>
                </div>
            {% endfor %}
        </div>
    </div>

    {# situation-specific BMD Graphs #}
    <div class="mt-4 d-flex flex-column " style="width: 90%; margin:auto;">
        <h3> Situation Specific BMD Graphs </h3>
        <div id="graphs" class="d-flex flex-row flex-wrap border border-secondary rounded p-3"
             style="max-height: 400px; overflow: auto;">
            <h6 class="text-center w-100 text-primary"><i>Select situational factors to find situation-specific BMD
                    Graphs </i></h6>

            <div id="spinner" style="display: none;">
                <div class="d-flex align-items-center">
                    <strong>Loading...</strong>
                    <div class="spinner-border ml-auto" role="status" aria-hidden="true"></div>
                </div>
            </div>

        </div>
    </div>

    {# Construct situational Method #}
    <div class="mt-5 d-flex flex-column ">
        <h3 class="m-auto"> Construct Situational Method</h3>
        <div style="width: 90%; height:800px; border: 1px solid black; border-radius: 2%; margin:auto">
            <h6 class=" mt-4 text-center w-100 text-success"><i>Select BMD Graphs to Construct a situational
                    method. </i></h6>
            <div id="situational-methods"
                 style="width: 100%; height: 93%; display: flex; flex-direction: row; align-items: flex-start">

            </div>
        </div>
    </div>

    {# Modal 1 #}
    <div class="modal-dialog" role="document"
         style="position: fixed;top: 8%; left:10%;display: none; width: 500px;" id="node-popup" data-nodeId="">
        <div class="modal-content">
            <div class="modal-header">
                <label for="modal-process-type"><b>Select methods for this step</b></label>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body d-flex flex-column">
                <div class="d-flex flex-column" id="method-blocks-box">

                    <div id="spinner-2">
                        <strong>Loading...</strong>
                        <div class="spinner-border ml-auto" role="status" aria-hidden="true"></div>
                    </div>
                    {#-------------------Method Blocks Come Here -------------------------#}
                </div>
            </div>
            <div class="modal-footer"
                 style="display:flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap">
                <button type="button" class="btn btn-warning" id="hide-step-method-blocks" style="display: none;">
                    Hide/Show step's method blocks
                </button>

                <button type="button" class="btn btn-secondary" id="add-these-blocks">Add above method blocks to the
                    step
                </button>
            </div>
        </div>
    </div>

    {# Modal 2 #}
    <div id="node-popup-2" style="position: fixed;top: 8%; left:10%;display: none; width: 40%;" role="document">
        <div class="modal-content">
            <div class="modal-header bg-dark">
                <div class="input-group mb-3">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="root-node">Name of your situational method</span>
                    </div>
                    <input type="text" class="form-control"
                           placeholder="Elephant Trading Business" aria-label="Username"
                           aria-describedby="basic-addon1" id="name-of-root-node">
                </div>
                <button type="button" class="close bg-danger" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        </div>
    </div>

    {# Modal 3 : Popup For Method Blocks #}
    <div id="method-block-popup" tabindex="-1"
         style="position: fixed;top: 8%; left:10%;display: none; width: 60%; background: #a4cbf8"
         role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true" data-nodeId="">
        <div class="modal-content">
            {# Header #}
            <div class="modal-header">
                <h5 class="modal-title" id="name-of-method-block"> {#Name of block comes here#}</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>

            {# Body #}
            <div class="modal-body">
                {# input artifacts, output artifacts, roles and tools come here #}
                <div class="d-flex flex-column border rounded p-2 mt-2">
                    <h5>Input Artifacts</h5>
                    <div class="input-artifacts">

                    </div>
                </div>

                <div class="d-flex flex-column border rounded p-2 mt-2">
                    <h5>Output Artifacts</h5>
                    <div class="output-artifacts">

                    </div>
                </div>

                <div class="d-flex flex-column border rounded p-2 mt-2">
                    <h5>Roles</h5>
                    <div class="roles">

                    </div>
                </div>

                <div class="d-flex flex-column border rounded p-2 mt-2">
                    <h5>Tools</h5>
                    <div class="tools">

                    </div>
                </div>

            </div>

            {# Footer #}
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" data-dismiss="modal" id="remove-method-block">Remove Method
                    Block
                </button>
                <button type="button" class="btn btn-primary" id="save-method-block-data">Save Data</button>
            </div>

        </div>
    </div>


{% endblock %}

{% block javascripts %}
    {{ parent() }}
    <script>


        // create an array with nodes
        let nodes = [
            {
                id: 1,
                label: 'Name of your situational method',
                level: '0',
                shape: 'circle',
                color: '#bababa',
                margin: 8,
                title: "Double Click to change name"
            },
        ];

        let recordOfOldAndNewNodes = [];

        let edges = [];
        let network = null;
        let body = $("body");
        let nodePopup = $("#node-popup");
        let nodePopup2 = $("#node-popup-2")
        let methodBlockPopup = $("#method-block-popup");
        let processTypeInModal = $("#modal-process-type");
        let level = $("#level");
        let situationalMethods = $("#situational-methods");
        let nameOfRootNode = $("#name-of-root-node");
        let hideShowMethodBlocksOfStep = $("#hide-step-method-blocks");
        nameOfRootNode.val("");

        let nodePopupToRefer = null;
        let bmdGraphsBeingUsed = [];
        let tasks = [];
        let totalHiddenTrees = 0;
        let temporaryNode = null;

        let tools = JSON.parse(("{{ tools|json_encode }}").replace(/&quot;/ig, '"'));
        let roles = JSON.parse(("{{ roles|json_encode }}").replace(/&quot;/ig, '"'));

        let graphTemplate = (name, situationalFactors, nodes, edges) => `
           <div class="jumbotron m-2" style="width: 32%;">
                <h4 style="max-height: 20%; min-height: 20%; overflow: auto"><b>Name:</b> ${name}</h4>
                <p class="lead"><b>Description:</b>This is a simple hero unit, a simple jumbotron-style component for calling extra attention to featured content or information.</p>
                <hr class="my-4">
                <p style="max-height: 30%;min-height: 30%; overflow: auto;"><b>Situational Factors:</b> ${situationalFactors} </p>
                <p class="lead">
                    <button class="btn btn-primary btn-lg select-graph" data-name='${name}' data-nodes='${nodes}' data-edges='${edges}' type="button">Select this BMD Graph</button>
                </p>
            </div>`;

        $('#situational-factor-box input[type="checkbox"]').each(function () {
            $(this).prop('checked', false);
        });
        $('#situational-factor-box input[type=checkbox]').on("click", function () {
            let situationalFactors = [];
            $("#situational-factor-box input:checked").each(function () {
                situationalFactors.push($(this).val());
            });
            $("#spinner").css("display", "block");
            $("#graphs").children().not("#spinner").remove();

            $.ajax({
                type: 'POST',
                url: '{{ path('method_construction') }}',
                data: {
                    request_type: 'get_graphs',
                    situationalFactors: situationalFactors,
                },
                success: function (response) {
                    let obj = JSON.parse(JSON.stringify(response));
                    $("#spinner").css("display", "none");

                    if (obj.graphs.length > 0) {
                        obj.graphs.forEach(function (item, index) {
                            let graph = graphTemplate(item.name, item.situationalFactors, item.nodes, item.edges);
                            $("#graphs").append(graph);

                            $(".select-graph").each(function () {
                                if (bmdGraphsBeingUsed.includes($(this).data("name")))
                                    $(this).prop("disabled", true);
                            });

                            /* On Select a particular graph */
                            $(".select-graph").on("click", function (e) {
                                e.stopImmediatePropagation();
                                bmdGraphsBeingUsed.push($(this).data("name"));
                                $(this).prop("disabled", true);
                                situationalMethods.parent().find(".text-primary").remove();
                                let nodesInDatabase = JSON.parse($(this).attr("data-nodes"));
                                let edgesInDatabase = JSON.parse($(this).attr("data-edges"));
                                processChildGraphAndConnectToParentNode(nodesInDatabase, edgesInDatabase, nodes[0], $(this).data("name"));
                            });

                        });
                    } else {
                        $("#graphs").append(`<h6 class="mt-4 text-center w-100 text-primary"><i>Select situational factors to find situation-specific BMD
                    Graphs </i></h6>`);
                    }

                }
            });
        });


        initializeGraph(true);

        function initializeGraph(physicsStatus) {
            // create a network
            let container = document.getElementById('situational-methods');

            // provide the data in the vis format
            let data = {
                nodes: nodes,
                edges: edges
            };
            let options = {
                physics: {
                    enabled: physicsStatus,
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 300,
                        springConstant: 0.01,
                        nodeDistance: 300,
                        damping: 0.09
                    },
                    solver: 'hierarchicalRepulsion'
                },
                edges: {
                    length: 320// Longer edges between nodes.

                },
                layout: {
                    hierarchical: {
                        direction: "UD",
                        nodeSpacing: 350,
                    },
                },
                nodes: {
                    size: 35,
                    font: {
                        size: 20,
                        color: '#000000'
                    },
                    widthConstraint: {
                        maximum: 300
                    },
                    /*fixed: {
                        x: true,
                        y: true
                    },*/
                },
            };

            // initialize your network!
            network = new vis.Network(container, data, options);
            checkEvents();
        }

        function checkEvents() {

            network.on("doubleClick", function (params) {

                params.event = "[original event]";
                let parsedObject = JSON.parse(JSON.stringify(params, null, 4));
                let nodeId = parsedObject.nodes[0];

                let node = getNodeObject(nodeId);

                if (node === null) {
                    return;
                } else if (node.id === 1) {
                    showNodePopup(nodePopup2);
                } else if (node.id !== 1 && (node.shape === 'circle')) {
                    if (node.isHidden)
                        showAllSteps(nodeId);
                    else
                        hideAllSteps(nodeId);
                    return;
                } else if ((node.shape === 'box' || node.shape === 'diamond') && node.type === "processType") {
                    checkAndAddMethodBlocksToStep(node);
                } else if (node.type === 'methodBlock') {

                    let artifactHTML = (artifactType, artifact, nodeId) => `
                               <div class="d-flex flex-row flex-wrap border rounded mb-2 justify-content-between">
                                  <span style="width: 40%; display: flex; flex-direction: column; justify-content: center;
                                    color: #010668; margin-left:1%;">
                                      ${artifact}
                                  </span>
                                  <button class="remove-artifact btn btn-warning ml-3"
                                   data-id="${nodeId}" data-artifactType="${artifactType}">
                                        Remove ${artifact}
                                  </button>
                               </div>
                                `;

                    let toBeFilledUpRole = (key, nodeId) => `
                               <div class="to-be-filled-role d-flex flex-row flex-wrap mb-3">
                                   <div class="input-group" style="width: 70%;">
                                        <div class="input-group-prepend">
                                            <span class="input-group-text">${key}</span>
                                        </div>
                                        <input type="text" class="form-control" placeholder="Provide a name for ${key}" required>
                                   </div>
                                   <button class="remove-to-be-filled-role btn btn-warning" data-id="${nodeId}" data-role="${key}">
                                        Remove ${key}
                                   </button>
                               </div>
                                `;

                    let toBeFilledUpTool = (toolType, selectId, nodeId) => `
                               <div class="to-be-filled-tool d-flex flex-row flex-wrap mb-3 justify-content-between">
                                    <div style="display: flex; flex-direction: row; width: 66%;">
                                          <div class="input-group-prepend">
                                            <label class="input-group-text"><b>Tool Type: &nbsp</b> ${toolType} </label>
                                          </div>
                                          <select class="custom-select tool-select" id="${selectId}">
                                            <option selected>Choose a tool..</option>

                                          </select>
                                    </div>
                                   <button class="remove-to-be-filled-tool btn btn-warning"
                                        data-id="${nodeId}" data-toolType="${toolType}">Remove ${toolType}
                                   </button>
                               </div>
                                `;

                    nodePopupToRefer = methodBlockPopup;
                    showNodePopup(methodBlockPopup);
                    methodBlockPopup.attr("data-nodeId", node.id);

                    //Clear previous contents from the dom
                    $(".input-artifacts").children().remove();
                    $(".output-artifacts").children().remove();
                    $(".roles").children().remove();
                    $(".tools").children().remove();

                    $("#name-of-method-block").html("<b>Name of method block::</b> " + node.label);
                    for (let [key, value] of Object.entries(node)) {
                        if (key === 'inputArtifacts') {
                            node[key].forEach(function (artifact, index) {
                                if (artifact !== "")
                                    methodBlockPopup.find(".input-artifacts").append(artifactHTML('inputArtifact', artifact, node.id));
                            });
                        }
                        if (key === 'outputArtifacts') {
                            node[key].forEach(function (artifact, index) {
                                if (artifact !== "")
                                    methodBlockPopup.find(".output-artifacts").append(artifactHTML('outputArtifact', artifact, node.id));
                            });
                        }
                        if (roles.includes(key)) {
                            methodBlockPopup.find(".roles").append(toBeFilledUpRole(key, node.id));
                        }
                        if (key in tools) {
                            let selectId = key.replace(/ /g, '') + "-" + node.id;
                            methodBlockPopup.find(".tools").append(toBeFilledUpTool(key, selectId, node.id));

                            let toolsOptions = tools[key].split(",");
                            toolsOptions.forEach(function (item, index) {
                                $("#" + selectId).append(new Option(item, item));
                            });

                        }
                    }
                }

                $(".close").on("click", function (e) {
                    e.stopImmediatePropagation();
                    closeNodePopup(nodePopupToRefer);
                });
            });
        }

        let typingTimer;                //timer identifier
        let doneTypingInterval = 800;  //time in ms, 2 second for example

        //on keyup, start the countdown
        nameOfRootNode.on('keyup', function () {
            clearTimeout(typingTimer);
            typingTimer = setTimeout(setRootNodeName, doneTypingInterval);
        });

        //on keydown, clear the countdown
        nameOfRootNode.on('keydown', function () {
            clearTimeout(typingTimer);
        });

        $("#remove-method-block").on("click", function () {
            /* If the methodBlock's id and its rootNode id are different then the method block exists
            * in a tree where the root of the tree is the root node of the method block. Otherwise, the methodBlock,
            * has replaced the rootNode. Use the helper function "stepHasOnlyOneBlock". */

            let methodBlockId = methodBlockPopup.attr("data-nodeId");
            let methodBlockObject = getNodeObject(parseInt(methodBlockId));
            let rootOfMethodBlock = JSON.parse(methodBlockObject.rootNode);
            if (parseInt(methodBlockId) !== parseInt(rootOfMethodBlock.id)) //When methodblock not in place of processtype
                removeMethodBlock(parseInt(methodBlockId), parseInt(rootOfMethodBlock.id));
            else { //When methodblock sitting on top of process type
                nodes.forEach(function (node, index) {
                    if (parseInt(node.id) === parseInt(methodBlockId))
                        nodes.splice(index, 1);
                });
                tasks.forEach(function (task, index) {
                    if (parseInt(task.id) === parseInt(methodBlockId))
                        tasks.splice(index, 1);
                });
                nodes.push(rootOfMethodBlock);
                initializeGraph(true);
            }

            /*console.log(nodes, edges, tasks);*/
            closeNodePopup(methodBlockPopup);
        });


        /*-----------------------------Helper Functions ----------------------------------*/

        function setRootNodeName() {
            let rootNodeName = nameOfRootNode.val();
            if (rootNodeName.length < 5) {
                alert("Please give a valid name for the root node of your situational method!!");
                return false;
            }

            let rootNode = nodes[0];
            rootNode.label = rootNodeName;
            alert("Root node's name was set!!");
            initializeGraph(true);
        }

        function getNodeObject(nodeId) {
            let node = null;
            nodes.forEach(function (item, index) {
                if (item.id === nodeId)
                    node = item;
            });
            return node;
        }

        function closeNodePopup(divToClose) {
            divToClose.css("display", "none");
            $(".container-fluid").children().not(divToClose).css({
                "pointer-events": "auto",
            });
            $(".container-fluid").children().not(divToClose).css("opacity", "1");

            if (divToClose === nodePopup) {
                $("#method-blocks-box").children().not("#spinner-2").remove();
            }
        }

        function showNodePopup(divToShow) {

            if (divToShow === nodePopup) {
                $("#spinner-2").css("display", "block");
                $('#method-blocks-box input[type="checkbox"]').each(function () {
                    $(this).parent().remove();
                });
                $("#add-these-blocks").prop("disabled", true);
            }

            $(".container-fluid").children().not(divToShow).css({
                "pointer-events": "none",
                "opacity": "0.4"
            });
            divToShow.css("display", "block");
            nodePopupToRefer = divToShow;
        }

        function hideAllSteps(rootNodeId) {

            /*getNodeObject(rootNodeId).color = "brown";*/
            getNodeObject(rootNodeId).isHidden = true;
            edges.forEach(function (edge, index) {
                if (edge.from === rootNodeId && edge.color === "red") {
                    let node = getNodeObject(edge.to);
                    node.hidden = true;

                    //Check if the above nodeObject has tree or not
                    edges.forEach(function (edge, index) {
                        if (parseInt(edge.from) === parseInt(node.id) && edge.color === "red")
                            getNodeObject(edge.to).hidden = true;
                    });
                }
            });
            totalHiddenTrees++;
            initializeGraph(false);
        }

        function showAllSteps(rootNodeId) {
            /*getNodeObject(rootNodeId).color = "#bababa";*/
            getNodeObject(rootNodeId).isHidden = false;
            edges.forEach(function (edge, index) {
                if (edge.from === rootNodeId && edge.color === "red") {
                    let node = getNodeObject(edge.to);
                    node.hidden = false;

                    //Check if the above nodeObject has tree or not
                    edges.forEach(function (edge, index) {
                        if (parseInt(edge.from) === parseInt(node.id) && edge.color === "red")
                            getNodeObject(edge.to).hidden = false;
                    });
                }
            });
            totalHiddenTrees--;
            if (totalHiddenTrees === 0)
                initializeGraph(true);
            else
                initializeGraph(false);
        }

        function processChildGraphAndConnectToParentNode(childNodes, childEdges, parentNode, nameOfTheLocalGraph) {

            let totalNodeLength = nodes.length;
            let rootNodeOfChildGraph = childNodes[0];

            childNodes.forEach(function (node, index) {
                node.oldId = node.id;
                if (node.shape === 'circle') {
                    node.title = "Double click to collapse/expand";
                    node.isHidden = false;
                    node.graphName = nameOfTheLocalGraph;
                }

                if (node.shape === 'box') {
                    node.type = "processType";
                    node.isHidden = false;
                    node.rootNode = JSON.stringify(rootNodeOfChildGraph);
                }


                node.id = totalNodeLength + 1;
                node.margin = parseInt(node.margin);
                if (node === rootNodeOfChildGraph)
                    node.level = parseInt(parentNode.level) + 2;
                else
                    node.level = parseInt(rootNodeOfChildGraph.level) + parseInt(node.level);
                totalNodeLength++;
                nodes.push(node);
            });

            childEdges.forEach(function (edge, index) {
                childNodes.forEach(function (node, index) {
                    if (edge.from === node.oldId)
                        edge.from = node.id;
                    if (edge.to === node.oldId)
                        edge.to = node.id;
                });
                edges.push(edge);
            });

            /*
            Add the last edge from root node of the child graph
            to the parent node.
             */
            edges.push({'arrows': 'from', 'to': rootNodeOfChildGraph.id, 'from': parentNode.id, color: 'red'});
            if (totalHiddenTrees === 0)
                initializeGraph(true);
            else
                initializeGraph(false);
        }

        function getLocalRootNodeObject(nodeId) {

            let localRootNodeObject = null;
            edges.forEach(function (edge, index) {
                if (edge.arrows === "from" && edge.to === parseInt(nodeId) && edge.color === "red") {
                    localRootNodeObject = getNodeObject(parseInt(edge.from));
                }
            });
            return localRootNodeObject;
        }

        function checkIfLocalSupremeRootNodeReadyToBeExecuted(childNode) //This was previously a processType node
        {
            let localSupremeNode = getLocalRootNodeObject(childNode.id);

            let allLocalChildren = [];
            //Get all the edged nodes from child to local supreme and check if they are ready
            edges.forEach(function (edge, index) {
                if (edge.arrows === 'from' && parseInt(edge.from) === parseInt(localSupremeNode.id) && edge.color === "red")
                    allLocalChildren.push(getNodeObject(parseInt(edge.to)));
            });

            let allChildNodesAreActive = true;
            allLocalChildren.forEach(function (childNode, index) {
                if (childNode.color !== "#f86262")
                    allChildNodesAreActive = false;
            });

            if (allChildNodesAreActive)
                localSupremeNode.color = "#f86262";

            initializeGraph(true);
        }

        function stepAlreadyHasThisMethodBlock(tableIdOfMethodBlock, idOfStep) {
            let methodBlockExistInStep = false;
            edges.forEach(function (edge, index) {
                if (parseInt(edge.from) === idOfStep && edge.color === "red" && edge.arrows === "from") {
                    let nodeToCheck = getNodeObject(parseInt(edge.to));
                    if (parseInt(nodeToCheck.tableId) === parseInt(tableIdOfMethodBlock))
                        methodBlockExistInStep = true;
                }
            });
            return methodBlockExistInStep;
        }

        function stepHasOnlyOneBlock(idOfStep) {
            let hasOnlyOneBlock = false;
            nodes.forEach(function (node, index) {
                if ('rootNode' in node) {
                    let rootOfNode = JSON.parse(node.rootNode);
                    if (parseInt(rootOfNode.id) === parseInt(node.id) && parseInt(rootOfNode.id) === parseInt(idOfStep))
                        hasOnlyOneBlock = true;
                }
            });
            return hasOnlyOneBlock;
        }

        function stepHasNoMethodBlocksAtall(idOfStep) {
            let stepHasNoBlocks = false;
            let stepObject = getNodeObject(idOfStep);
            if ('label' in stepObject) {
                if ((stepObject.label).includes("<<"))
                    stepHasNoBlocks = true;
            }
            return stepHasNoBlocks;
        }

        function getHighestStepLevel() {
            let highestLevel = 0;
            nodes.forEach(function (node, index) {
                if (parseInt(node.level) > highestLevel)
                    highestLevel = parseInt(node.level);
            });

            return highestLevel;
        }

        function removeMethodBlock(methodBlockId, rootNodeIdOfMethodBlock) {
            let methodBlockRemoved = false;

            nodes.forEach(function (node, index) {
                if (parseInt(node.id) === parseInt(methodBlockId)) {
                    nodes.splice(index, 1);
                    methodBlockRemoved = true;
                }
            });

            if (methodBlockRemoved) {
                edges.forEach(function (edge, index) {
                    if (parseInt(edge.to) === parseInt(methodBlockId) && parseInt(rootNodeIdOfMethodBlock) === parseInt(edge.from)
                        && edge.color === "red")
                        edges.splice(index, 1);
                });

                tasks.forEach(function (task, index) {
                    if (parseInt(task.id) === parseInt(methodBlockId))
                        tasks.splice(index, 1);
                });

                if (stepHasOnlyOneBlock(rootNodeIdOfMethodBlock)) {
                    //Then get the last methodBlock
                    let lastMethodBlock = null;
                    let newLevelOftheLastMethodBlock = null;
                    edges.forEach(function (edge, index) {
                        if (parseInt(rootNodeIdOfMethodBlock) === parseInt(edge.from) && edge.color === "red") {
                            lastMethodBlock = getNodeObject(parseInt(edge.to));
                            edges.splice(index, 1);
                        }

                    });
                    let rootRemoved = false;
                    nodes.forEach(function (node, index) {
                        if (parseInt(node.id) === parseInt(rootNodeIdOfMethodBlock)) {
                            newLevelOftheLastMethodBlock = node.level;
                            nodes.splice(index, 1);
                            rootRemoved = true;
                        }
                    });
                    if (rootRemoved) {
                        lastMethodBlock.id = rootNodeIdOfMethodBlock;
                        lastMethodBlock.level = newLevelOftheLastMethodBlock;
                    }
                }

                initializeGraph(true);
            }
        }

        function refreshedNodeValue() {
            return temporaryNode;
        }

        function checkAndAddMethodBlocksToStep(node) { //This node is the processType actually
            showNodePopup(nodePopup);
            nodePopup.attr("data-nodeId", node.id);
            let localRootNode = getLocalRootNodeObject(node.id); //The localRootNode is root node of graph

            if (node.shape === 'diamond') {
                hideShowMethodBlocksOfStep.css("display", "block");
                hideShowMethodBlocksOfStep.on("click", function (e) {
                    e.stopImmediatePropagation();
                    node = refreshedNodeValue();
                    if (node.isHidden)
                        showAllSteps(node.id);
                    else
                        hideAllSteps(node.id);
                    closeNodePopup(nodePopup);
                });
            }

            $.ajax({
                type: 'POST',
                url: '{{ path('method_construction') }}',
                data: {
                    request_type: 'get_method_blocks',
                    process_type: 'label' in node ?
                        (node.label).replace(">>", "").replace("<<", "") : node.title,
                    graph_name: localRootNode.graphName,
                },
                success: function (response) {
                    $("#spinner-2").css("display", "none");
                    let obj = JSON.parse(JSON.stringify(response));

                    let methodBlockDiv = (id, name, inputArtifacts, outputArtifacts, roles, tools) => `
                              <div class="form-check" data-roles="${roles}" data-inputArtifacts="${inputArtifacts}"
                               data-outputArtifacts="${outputArtifacts}" data-tools="${tools}" data-id="${id}">
                                    <input class="form-check-input" type="checkbox" value="" id="method-block-${id}">
                                    <label class="form-check-label" for="method-block-${id}">
                                        <a target="_blank" href="/method/building/block/${id}">${name}</a>
                                    </label>
                              </div>
                            `;
                    obj.data.forEach(function (item, index) {

                        if (!stepAlreadyHasThisMethodBlock(item.id, node.id)) {
                            $("#method-blocks-box").append(methodBlockDiv(
                                item.id, item.name, item.inputArtifacts, item.outputArtifacts, item.roles, item.tools
                            ));
                        }
                    });


                    $('#method-blocks-box input[type=checkbox]').on("click", function () {

                        let totalBlocks = $('#method-blocks-box input[type="checkbox"]:checked').length;

                        if (totalBlocks > 0)
                            $("#add-these-blocks").prop("disabled", false);
                        else
                            $("#add-these-blocks").prop("disabled", true);
                    });

                    temporaryNode = node;

                    $("#add-these-blocks").on("click", function (e) {

                        e.stopImmediatePropagation();
                        let totalBlocks = $('#method-blocks-box input[type="checkbox"]:checked').length;

                        node = temporaryNode;
                        let nodeLabel = 'label' in node ?
                            node.label.replace("<<", "").replace(">>", "") : node.title;

                        let rootNodeOfMethodBlock = JSON.stringify(node);

                        $('#method-blocks-box input[type="checkbox"]:checked').each(function (index) {

                            let roles = $(this).parent().attr("data-roles").split(",");
                            let tools = $(this).parent().attr("data-tools").split(",");

                            if (totalBlocks === 1 && stepHasNoMethodBlocksAtall(node.id)) {

                                node.label = ($(this).next('label').text()).trim();
                                node.color = "#bababa";
                                node.type = "methodBlock";
                                node.inputArtifacts = ($(this).parent().attr("data-inputArtifacts")).split(",");
                                node.outputArtifacts = $(this).parent().attr("data-outputArtifacts").split(",");
                                node.tableId = $(this).parent().attr("data-id");
                                node.rootNode = rootNodeOfMethodBlock;
                                roles.forEach(function (role, index) {
                                    node[role] = null;
                                });
                                tools.forEach(function (tool, index) {
                                    node[tool] = null;
                                });
                                tasks.push(node);

                            } else if (totalBlocks >= 1 && stepHasOnlyOneBlock(node.id)) {

                                let level = getLevelForMethodBlock(node, nodeLabel);

                                //first handle the original sitting block
                                let newIdForTheSittingMethodBlock = Date.now();
                                nodes.forEach(function (item, index) {
                                    if (parseInt(item.id) === parseInt(node.id)) {
                                        item.id = newIdForTheSittingMethodBlock;
                                        nodes.push(node);
                                    }
                                });
                                let redEdgeFromSittingMethodBlock = {
                                    from: node.id, to: newIdForTheSittingMethodBlock, arrows: "from", color: "red"
                                };

                                //Then handle the block being reach through .each function
                                let methodBlock = {
                                    id: Date.now() + index,
                                    shape: 'box',
                                    type: 'methodBlock',
                                    processType: nodeLabel,
                                    color: "#bababa",
                                    margin: 8,
                                    level: level,
                                    label: ($(this).next('label').text()).trim(),
                                    rootNode: rootNodeOfMethodBlock,
                                    tableId: $(this).parent().attr("data-id"),
                                    inputArtifacts: $(this).parent().attr("data-inputArtifacts").split(","),
                                    outputArtifacts: $(this).parent().attr("data-outputArtifacts").split(",")
                                };
                                roles.forEach(function (role, index) {
                                    methodBlock[role] = null;
                                });
                                tools.forEach(function (tool, index) {
                                    methodBlock[tool] = null;
                                });

                                tasks.push(methodBlock);
                                nodes.push(methodBlock);

                                let edgeFromMethodBlockToProcessType = {
                                    id: Date.now() + index,
                                    from: node.id,
                                    to: methodBlock.id,
                                    arrows: "from",
                                    color: "red"
                                }

                                edges.push(edgeFromMethodBlockToProcessType);

                            } else {

                                let level = getLevelForMethodBlock(node, nodeLabel);

                                let methodBlock = {
                                    id: Date.now() + index,
                                    shape: 'box',
                                    type: 'methodBlock',
                                    processType: nodeLabel,
                                    color: "#bababa",
                                    margin: 8,
                                    level: level,
                                    label: ($(this).next('label').text()).trim(),
                                    rootNode: rootNodeOfMethodBlock,
                                    tableId: $(this).parent().attr("data-id"),
                                    inputArtifacts: $(this).parent().attr("data-inputArtifacts").split(","),
                                    outputArtifacts: $(this).parent().attr("data-outputArtifacts").split(",")
                                };

                                roles.forEach(function (role, index) {
                                    methodBlock[role] = null;
                                });
                                tools.forEach(function (tool, index) {
                                    methodBlock[tool] = null;
                                });

                                tasks.push(methodBlock);
                                nodes.push(methodBlock);

                                node = refreshedNodeValue();

                                let edgeFromMethodBlockToProcessType = {
                                    id: Date.now() + index,
                                    from: node.id,
                                    to: methodBlock.id,
                                    arrows: "from",
                                    color: "red"
                                }

                                edges.push(edgeFromMethodBlockToProcessType);
                            }

                            if ((totalBlocks > 1 || (totalBlocks === 1 && stepHasOnlyOneBlock(node.id))) && node.shape !== 'diamond') {
                                node.title = nodeLabel;
                                if ('label' in node)
                                    delete node.label;
                                node.shape = "diamond";
                                node.color = "#bababa";
                            }
                        });

                        /*checkIfLocalSupremeRootNodeReadyToBeExecuted(node);*/
                        initializeGraph(true);
                        closeNodePopup(nodePopup);
                    });

                }
            });
        }

        function getLevelForMethodBlock(node, nodeLabel) {
            /* Determine the level of each method block */
            let level = getHighestStepLevel() + 1;

            if (tasks.length === 0) {
                level = getHighestStepLevel() + 2;

            } else {
                console.log(tasks);
                tasks.forEach(function (task, index) {
                    let rootNode = JSON.parse(task.rootNode);

                    if (task.processType === nodeLabel && parseInt(rootNode.id) === parseInt(node.id)) {
                        level = task.level;
                    }
                });
            }
            return level;
        }

    </script>
{% endblock %}
